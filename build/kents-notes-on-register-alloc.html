<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- DO NOT EDIT THIS FILE-->
<!-- Edit the .tex version instead-->
<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>Assignment 4</title>
<link href="kents-notes-on-register-alloc_files/base.css" rel="stylesheet" type="text/css">
</head>
<body>


<h1>Assignment 4</h1>

 



<p>


</p>

<a name="g0"></a>

<h3><br><a name="./assign4:h0"></a>1. Background<a name="section:background"></a></h3>



<p>
In this assignment, we turn the job of allocating regsiters for our local
variables over to the compiler, while still allowing ourselves to assign
and reference register and frame variables explicitly.
The compiler will use a graph-coloring register allocator.

</p><p>
Graph-coloring register allocation is based on the problem of coloring
directly connected nodes of a graph different colors, just as we might
color adjacent geographic regions on a map different colors.
With a graph-coloring register allocator, the nodes of the graph are
variables and registers, the links between nodes represent conflicts
between variables and registers, and the colors are specific registers,
e.g., <tt>rax</tt> or <tt>r12</tt>.
So the idea is that we are trying to assign different registers to
conflicting variables, but pack those that do not conflict together
where possible so that we can locate as many variables in registers
as we can.

</p><p>
A conflict between two variables means we cannot assign both to the
same register, and a conflict between a variable and a register means
we cannot assign the variable to the register.
The first step of the algorithm is to determine where conflicts
exist.
We do this via live analysis.

</p><p>

<a name="g1"></a>

</p><h4><br><a name="./assign4:h1"></a>1.1. Live Analysis<a name="section:liveanalysis"></a></h4>



<p>
Two variables or a variable and a register <i>conflict</i> if:

</p><p>
</p><ul>
 <li>a.  one is in use (live) at some point where the other is assigned
 </li><li>b.  the assignment isn't a simple move from one to the other
</li></ul>
<p>

</p><p>
To see why this is the case, imagine that we are considering assigning two
variables <tt><i>x</i></tt> and <tt><i>y</i></tt> to the same register.
If, over the span of instructions where <tt><i>x</i></tt> is in use, there is no
assignment to <tt><i>y</i></tt>, then we know that putting <tt><i>y</i></tt> in the same
register will not wipe out <tt><i>x</i></tt>.
If <tt><i>y</i></tt> is assigned within the span of instructions where <tt><i>x</i></tt>
is in use, however, the assignment has the potential to wipe out the value
in <tt><i>x</i></tt>, unless it happens that the value being stored in <tt><i>y</i></tt>
is the same value as is already stored in <tt><i>x</i></tt>, which we generally
know to be the case only if the assignment is a straight assignment of
<tt><i>x</i></tt> to <tt><i>y</i></tt>.

</p><p>
A variable or register is in use, or <i>live</i>, at any given point,
if the variable's value might yet be needed by the program.
In general, this is an undecidable property,
so we conservatively assume that the variable is live if we
cannot prove that it is not live.
The traditional conservative approximation, which we use, is that a
variable is live at a given point if any reference to the variable occurs
along any flow of control from the given point before the variable
is <i>killed</i> (overwritten) by an intervening assignment to the
variable.

</p><p>
Consider the following example.

</p><p>

</p><p><tt>(begin<br>

&nbsp;&nbsp;(set!&nbsp;a&nbsp;r8)<br>

&nbsp;&nbsp;(set!&nbsp;b&nbsp;fv0)<br>

&nbsp;&nbsp;(set!&nbsp;c&nbsp;(+&nbsp;a&nbsp;2))<br>

&nbsp;&nbsp;(if&nbsp;(&lt;&nbsp;c&nbsp;0)&nbsp;(nop)&nbsp;(set!&nbsp;c&nbsp;(+&nbsp;c&nbsp;b)))<br>

&nbsp;&nbsp;(set!&nbsp;rax&nbsp;(+&nbsp;c&nbsp;1))<br>

&nbsp;&nbsp;(r15&nbsp;rax&nbsp;rbp))</tt>
</p><p>At the point where <tt>a</tt> is assigned, neither <tt>b</tt> nor
<tt>c</tt> is live.
The values in those variables, if any, cannot be used, since they
are overwritten by assignments before any references occur.
At the point where <tt>b</tt> is assigned, <tt>a</tt> is live, since
it is referenced after that point, but <tt>c</tt> is not.
At the point where <tt>c</tt> is assigned, <tt>b</tt> is live but
<tt>a</tt> is not.

</p><p>
Since <tt>a</tt> is live where <tt>b</tt> is assigned, and it is not
a straight assignment of <tt>b</tt> to <tt>a</tt>, <tt>a</tt> and
<tt>b</tt> conflict.
Similarly, <tt>b</tt> and <tt>c</tt> conflict, because <tt>c</tt> is
assigned where <tt>b</tt> is live.
But <tt>a</tt> and <tt>c</tt> do not conflict, since neither is
live where the other is assigned.
Thus, it is possible to put <tt>a</tt> and <tt>c</tt> in the same
register, but not <tt>a</tt> and <tt>b</tt> or <tt>b</tt> and
<tt>c</tt>.

</p><p>
Because the liveness of a variable is determined by whether it may yet be
referenced, live analysis is performed backward along the flow of control
from the leaves of a computation.
We'll perform live analysis on one procedure at a time, so the leaves in
our case are tail calls, which now list the set of locatons considered
live at the point of the call.
As the analysis works backward from the tail calls, it adds variables and
registers when it sees references to them and removes variables and
registers when it sees assignments to them.
When operating on an <tt>if</tt> expression, it computes the live sets
separately for the consequent and alternative.
Because we don't know which will be executed, variables live in either
should be considered live on exit from the test expression, so the natural
approach is to union the two sets together before proceding upward along
the flow of control in the test part.
(We can do something a bit more clever than this, as we'll discuss later.)

</p><p>
Assuming the example above is the entire body of a procedure, live
analysis proceeds from bottom to top as follows.

</p><p>


</p><p>
1.&nbsp;The live set is initialized to {<tt>rax</tt>,<tt>rbp</tt>}, which is the
set of variables listed as live in the tail call.

</p><p></p><table border="1"><tbody><tr><td nowrap="nowrap" align="right">

              </td><td nowrap="nowrap" align="left"> instruction          </td><td nowrap="nowrap" align="left"> live after instruction </td><td nowrap="nowrap" align="left"> live after RHS</td></tr><tr><td nowrap="nowrap" align="right">
              </td><td nowrap="nowrap" align="left"> <tt>(set!&nbsp;a&nbsp;r8)</tt>          </td><td nowrap="nowrap" align="left">                        </td><td nowrap="nowrap" align="left">               </td></tr><tr><td nowrap="nowrap" align="right">
              </td><td nowrap="nowrap" align="left"> <tt>(set!&nbsp;b&nbsp;fv0)</tt>         </td><td nowrap="nowrap" align="left">                        </td><td nowrap="nowrap" align="left">               </td></tr><tr><td nowrap="nowrap" align="right">
              </td><td nowrap="nowrap" align="left"> <tt>(set!&nbsp;c&nbsp;(+&nbsp;a&nbsp;2))</tt>     </td><td nowrap="nowrap" align="left">                        </td><td nowrap="nowrap" align="left">               </td></tr><tr><td nowrap="nowrap" align="right">
              </td><td nowrap="nowrap" align="left"> <tt>(if&nbsp;(&lt;&nbsp;c&nbsp;0)</tt>          </td><td nowrap="nowrap" align="left">                        </td><td nowrap="nowrap" align="left">               </td></tr><tr><td nowrap="nowrap" align="right">
              </td><td nowrap="nowrap" align="left"> <tt>&nbsp;&nbsp;&nbsp;&nbsp;(nop)</tt>            </td><td nowrap="nowrap" align="left">                        </td><td nowrap="nowrap" align="left">               </td></tr><tr><td nowrap="nowrap" align="right">
              </td><td nowrap="nowrap" align="left"> <tt>&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;c&nbsp;(+&nbsp;c&nbsp;b)))</tt></td><td nowrap="nowrap" align="left">                        </td><td nowrap="nowrap" align="left">               </td></tr><tr><td nowrap="nowrap" align="right">
              </td><td nowrap="nowrap" align="left"> <tt>(set!&nbsp;rax&nbsp;(+&nbsp;c&nbsp;1))</tt>   </td><td nowrap="nowrap" align="left">                        </td><td nowrap="nowrap" align="left">               </td></tr><tr><td nowrap="nowrap" align="right">
<img src="kents-notes-on-register-alloc_files/0.gif" alt="&lt;graphic&gt;"> </td><td nowrap="nowrap" align="left"> <tt>(r15&nbsp;rax&nbsp;rbp))</tt>       </td><td nowrap="nowrap" align="left"> {<tt>rax</tt>,<tt>rbp</tt>} </td><td nowrap="nowrap" align="left"></td></tr><tr><td colspan="4" nowrap="nowrap" align="left">

conflicts for
    <tt>a</tt>: {},
    <tt>b</tt>: {},
    <tt>c</tt>: {}

</td></tr></tbody></table>

<p>
</p><p>2.&nbsp;To this is added <tt>r15</tt>, since it is referenced by the tail call.

</p><p></p><table border="1"><tbody><tr><td nowrap="nowrap" align="center">

              </td><td nowrap="nowrap" align="left"> instruction          </td><td nowrap="nowrap" align="left"> live after instruction </td><td nowrap="nowrap" align="left"> live after RHS</td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(set!&nbsp;a&nbsp;r8)</tt>          </td><td nowrap="nowrap" align="left">                        </td><td nowrap="nowrap" align="left">               </td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(set!&nbsp;b&nbsp;fv0)</tt>         </td><td nowrap="nowrap" align="left">                        </td><td nowrap="nowrap" align="left">               </td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(set!&nbsp;c&nbsp;(+&nbsp;a&nbsp;2))</tt>     </td><td nowrap="nowrap" align="left">                        </td><td nowrap="nowrap" align="left">               </td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(if&nbsp;(&lt;&nbsp;c&nbsp;0)</tt>          </td><td nowrap="nowrap" align="left">                        </td><td nowrap="nowrap" align="left">               </td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>&nbsp;&nbsp;&nbsp;&nbsp;(nop)</tt>            </td><td nowrap="nowrap" align="left">                        </td><td nowrap="nowrap" align="left">               </td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;c&nbsp;(+&nbsp;c&nbsp;b)))</tt></td><td nowrap="nowrap" align="left">                        </td><td nowrap="nowrap" align="left">               </td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(set!&nbsp;rax&nbsp;(+&nbsp;c&nbsp;1))</tt>   </td><td nowrap="nowrap" align="left"> {<tt>rax</tt>,<tt>rbp</tt>,<tt>r15</tt>} </td><td nowrap="nowrap" align="left"></td></tr><tr><td nowrap="nowrap" align="center">
<img src="kents-notes-on-register-alloc_files/0.gif" alt="&lt;graphic&gt;"> </td><td nowrap="nowrap" align="left"> <tt>(r15&nbsp;rax&nbsp;rbp))</tt>       </td><td nowrap="nowrap" align="left"> {<tt>rax</tt>,<tt>rbp</tt>} </td><td nowrap="nowrap" align="left"></td></tr><tr><td colspan="4" nowrap="nowrap" align="left">

conflicts for
    <tt>a</tt>: {},
    <tt>b</tt>: {},
    <tt>c</tt>: {}

</td></tr></tbody></table>

<p>
</p><p>3.&nbsp;The assignment to <tt>rax</tt> kills <tt>rax</tt>, removing it from
the set of variables and registers live after the assignment.
No conflicts are added at this point because the LHS is a register
and no variables appear in the live set.

</p><p></p><table border="1"><tbody><tr><td nowrap="nowrap" align="center">

              </td><td nowrap="nowrap" align="left"> instruction          </td><td nowrap="nowrap" align="left"> live after instruction </td><td nowrap="nowrap" align="left"> live after RHS</td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(set!&nbsp;a&nbsp;r8)</tt>          </td><td nowrap="nowrap" align="left">                        </td><td nowrap="nowrap" align="left">               </td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(set!&nbsp;b&nbsp;fv0)</tt>         </td><td nowrap="nowrap" align="left">                        </td><td nowrap="nowrap" align="left">               </td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(set!&nbsp;c&nbsp;(+&nbsp;a&nbsp;2))</tt>     </td><td nowrap="nowrap" align="left">                        </td><td nowrap="nowrap" align="left">               </td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(if&nbsp;(&lt;&nbsp;c&nbsp;0)</tt>          </td><td nowrap="nowrap" align="left">                        </td><td nowrap="nowrap" align="left">               </td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>&nbsp;&nbsp;&nbsp;&nbsp;(nop)</tt>            </td><td nowrap="nowrap" align="left">                        </td><td nowrap="nowrap" align="left">               </td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;c&nbsp;(+&nbsp;c&nbsp;b)))</tt></td><td nowrap="nowrap" align="left">                        </td><td nowrap="nowrap" align="left">               </td></tr><tr><td nowrap="nowrap" align="center">
<img src="kents-notes-on-register-alloc_files/0.gif" alt="&lt;graphic&gt;"> </td><td nowrap="nowrap" align="left"> <tt>(set!&nbsp;rax&nbsp;(+&nbsp;c&nbsp;1))</tt>   </td><td nowrap="nowrap" align="left"> {<tt>rax</tt>,<tt>rbp</tt>,<tt>r15</tt>} </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>}</td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(r15&nbsp;rax&nbsp;rbp))</tt>       </td><td nowrap="nowrap" align="left"> {<tt>rax</tt>,<tt>rbp</tt>} </td><td nowrap="nowrap" align="left"></td></tr><tr><td colspan="4" nowrap="nowrap" align="left">

conflicts for
    <tt>a</tt>: {},
    <tt>b</tt>: {},
    <tt>c</tt>: {}

</td></tr></tbody></table>

<p>
</p><p>4.&nbsp;Since the right-hand side of the assignment
references <tt>c</tt>, we add <tt>c</tt> to the set.
This set is used both for the consequent
and alternative of the <tt>if</tt>.

</p><p></p><table border="1"><tbody><tr><td nowrap="nowrap" align="center">

              </td><td nowrap="nowrap" align="left"> instruction          </td><td nowrap="nowrap" align="left"> live after instruction </td><td nowrap="nowrap" align="left"> live after RHS</td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(set!&nbsp;a&nbsp;r8)</tt>          </td><td nowrap="nowrap" align="left">                        </td><td nowrap="nowrap" align="left">               </td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(set!&nbsp;b&nbsp;fv0)</tt>         </td><td nowrap="nowrap" align="left">                        </td><td nowrap="nowrap" align="left">               </td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(set!&nbsp;c&nbsp;(+&nbsp;a&nbsp;2))</tt>     </td><td nowrap="nowrap" align="left">                        </td><td nowrap="nowrap" align="left">               </td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(if&nbsp;(&lt;&nbsp;c&nbsp;0)</tt>          </td><td nowrap="nowrap" align="left">                        </td><td nowrap="nowrap" align="left">               </td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>&nbsp;&nbsp;&nbsp;&nbsp;(nop)</tt>            </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>c</tt>} </td><td nowrap="nowrap" align="left"></td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;c&nbsp;(+&nbsp;c&nbsp;b)))</tt></td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>c</tt>} </td><td nowrap="nowrap" align="left"></td></tr><tr><td nowrap="nowrap" align="center">
<img src="kents-notes-on-register-alloc_files/0.gif" alt="&lt;graphic&gt;"> </td><td nowrap="nowrap" align="left"> <tt>(set!&nbsp;rax&nbsp;(+&nbsp;c&nbsp;1))</tt>   </td><td nowrap="nowrap" align="left"> {<tt>rax</tt>,<tt>rbp</tt>,<tt>r15</tt>} </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>}</td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(r15&nbsp;rax&nbsp;rbp))</tt>       </td><td nowrap="nowrap" align="left"> {<tt>rax</tt>,<tt>rbp</tt>} </td><td nowrap="nowrap" align="left"></td></tr><tr><td colspan="4" nowrap="nowrap" align="left">

conflicts for
    <tt>a</tt>: {},
    <tt>b</tt>: {},
    <tt>c</tt>: {}

</td></tr></tbody></table>

<p>
</p><p>5.&nbsp;The assignment in the alternative kills <tt>c</tt>.
<tt>r15</tt> and <tt>rbp</tt> are live here, where <tt>c</tt> is assigned,
so we record that <tt>c</tt> conflicts with <tt>r15</tt> and <tt>rbp</tt>.

</p><p>

</p><p></p><table border="1"><tbody><tr><td nowrap="nowrap" align="center">

              </td><td nowrap="nowrap" align="left"> instruction          </td><td nowrap="nowrap" align="left"> live after instruction </td><td nowrap="nowrap" align="left"> live after RHS</td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(set!&nbsp;a&nbsp;r8)</tt>          </td><td nowrap="nowrap" align="left">                        </td><td nowrap="nowrap" align="left">               </td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(set!&nbsp;b&nbsp;fv0)</tt>         </td><td nowrap="nowrap" align="left">                        </td><td nowrap="nowrap" align="left">               </td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(set!&nbsp;c&nbsp;(+&nbsp;a&nbsp;2))</tt>     </td><td nowrap="nowrap" align="left">                        </td><td nowrap="nowrap" align="left">               </td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(if&nbsp;(&lt;&nbsp;c&nbsp;0)</tt>          </td><td nowrap="nowrap" align="left">                        </td><td nowrap="nowrap" align="left">               </td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>&nbsp;&nbsp;&nbsp;&nbsp;(nop)</tt>            </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>c</tt>} </td><td nowrap="nowrap" align="left"></td></tr><tr><td nowrap="nowrap" align="center">
<img src="kents-notes-on-register-alloc_files/0.gif" alt="&lt;graphic&gt;"> </td><td nowrap="nowrap" align="left"> <tt>&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;c&nbsp;(+&nbsp;c&nbsp;b)))</tt></td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>c</tt>} </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>}</td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(set!&nbsp;rax&nbsp;(+&nbsp;c&nbsp;1))</tt>   </td><td nowrap="nowrap" align="left"> {<tt>rax</tt>,<tt>rbp</tt>,<tt>r15</tt>} </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>}</td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(r15&nbsp;rax&nbsp;rbp))</tt>       </td><td nowrap="nowrap" align="left"> {<tt>rax</tt>,<tt>rbp</tt>} </td><td nowrap="nowrap" align="left"></td></tr><tr><td colspan="4" nowrap="nowrap" align="left">

conflicts for
    <tt>a</tt>: {},
    <tt>b</tt>: {},
    <tt>c</tt>: {<tt>r15</tt>,<tt>rbp</tt>}

</td></tr></tbody></table>

<p>
</p><p>6.&nbsp;The right-hand-side add <tt>c</tt> back, along with <tt>b</tt>.

</p><p></p><table border="1"><tbody><tr><td nowrap="nowrap" align="center">

              </td><td nowrap="nowrap" align="left"> instruction          </td><td nowrap="nowrap" align="left"> live after instruction </td><td nowrap="nowrap" align="left"> live after RHS</td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(set!&nbsp;a&nbsp;r8)</tt>          </td><td nowrap="nowrap" align="left"> </td><td nowrap="nowrap" align="left"></td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(set!&nbsp;b&nbsp;fv0)</tt>         </td><td nowrap="nowrap" align="left"> </td><td nowrap="nowrap" align="left"></td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(set!&nbsp;c&nbsp;(+&nbsp;a&nbsp;2))</tt>     </td><td nowrap="nowrap" align="left"> </td><td nowrap="nowrap" align="left"></td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(if&nbsp;(&lt;&nbsp;c&nbsp;0)</tt>          </td><td nowrap="nowrap" align="left"> </td><td nowrap="nowrap" align="left"></td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>&nbsp;&nbsp;&nbsp;&nbsp;(nop)</tt>            </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>c</tt>} </td><td nowrap="nowrap" align="left"></td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <i>before alternative:</i>    </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>c</tt>,<tt>b</tt>} </td><td nowrap="nowrap" align="left"></td></tr><tr><td nowrap="nowrap" align="center">
<img src="kents-notes-on-register-alloc_files/0.gif" alt="&lt;graphic&gt;"> </td><td nowrap="nowrap" align="left"> <tt>&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;c&nbsp;(+&nbsp;c&nbsp;b)))</tt></td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>c</tt>} </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>}</td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(set!&nbsp;rax&nbsp;(+&nbsp;c&nbsp;1))</tt>   </td><td nowrap="nowrap" align="left"> {<tt>rax</tt>,<tt>rbp</tt>,<tt>r15</tt>} </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>}</td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(r15&nbsp;rax&nbsp;rbp))</tt>       </td><td nowrap="nowrap" align="left"> {<tt>rax</tt>,<tt>rbp</tt>} </td><td nowrap="nowrap" align="left"></td></tr><tr><td colspan="4" nowrap="nowrap" align="left">

conflicts for
    <tt>a</tt>: {},
    <tt>b</tt>: {},
    <tt>c</tt>: {<tt>r15</tt>,<tt>rbp</tt>}

</td></tr></tbody></table>

<p>
</p><p>7.&nbsp;The <tt>nop</tt> doesn't remove or add anything, so the set before the consequent
is the same as the set after.

</p><p></p><table border="1"><tbody><tr><td nowrap="nowrap" align="center">

              </td><td nowrap="nowrap" align="left"> instruction          </td><td nowrap="nowrap" align="left"> live after instruction </td><td nowrap="nowrap" align="left"> live after RHS</td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(set!&nbsp;a&nbsp;r8)</tt>          </td><td nowrap="nowrap" align="left"> </td><td nowrap="nowrap" align="left"></td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(set!&nbsp;b&nbsp;fv0)</tt>         </td><td nowrap="nowrap" align="left"> </td><td nowrap="nowrap" align="left"></td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(set!&nbsp;c&nbsp;(+&nbsp;a&nbsp;2))</tt>     </td><td nowrap="nowrap" align="left"> </td><td nowrap="nowrap" align="left"></td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(if&nbsp;(&lt;&nbsp;c&nbsp;0)</tt>          </td><td nowrap="nowrap" align="left"> </td><td nowrap="nowrap" align="left"></td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <i>before consequent:</i>     </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>c</tt>} </td><td nowrap="nowrap" align="left"></td></tr><tr><td nowrap="nowrap" align="center">
<img src="kents-notes-on-register-alloc_files/0.gif" alt="&lt;graphic&gt;"> </td><td nowrap="nowrap" align="left"> <tt>&nbsp;&nbsp;&nbsp;&nbsp;(nop)</tt>            </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>c</tt>} </td><td nowrap="nowrap" align="left"></td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <i>before alternative:</i>    </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>c</tt>,<tt>b</tt>} </td><td nowrap="nowrap" align="left"></td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;c&nbsp;(+&nbsp;c&nbsp;b)))</tt></td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>c</tt>} </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>}</td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(set!&nbsp;rax&nbsp;(+&nbsp;c&nbsp;1))</tt>   </td><td nowrap="nowrap" align="left"> {<tt>rax</tt>,<tt>rbp</tt>,<tt>r15</tt>} </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>}</td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(r15&nbsp;rax&nbsp;rbp))</tt>       </td><td nowrap="nowrap" align="left"> {<tt>rax</tt>,<tt>rbp</tt>} </td><td nowrap="nowrap" align="left"></td></tr><tr><td colspan="4" nowrap="nowrap" align="left">

conflicts for
    <tt>a</tt>: {},
    <tt>b</tt>: {},
    <tt>c</tt>: {<tt>r15</tt>,<tt>rbp</tt>}

</td></tr></tbody></table>

<p>
</p><p>8.&nbsp;The union of the consequent and alternative sets is used for <tt>&lt;</tt> call.

</p><p></p><table border="1"><tbody><tr><td nowrap="nowrap" align="center">

              </td><td nowrap="nowrap" align="left"> instruction          </td><td nowrap="nowrap" align="left"> live after instruction </td><td nowrap="nowrap" align="left"> live after RHS</td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(set!&nbsp;a&nbsp;r8)</tt>          </td><td nowrap="nowrap" align="left">                        </td><td nowrap="nowrap" align="left">               </td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(set!&nbsp;b&nbsp;fv0)</tt>         </td><td nowrap="nowrap" align="left">                        </td><td nowrap="nowrap" align="left">               </td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(set!&nbsp;c&nbsp;(+&nbsp;a&nbsp;2))</tt>     </td><td nowrap="nowrap" align="left">                        </td><td nowrap="nowrap" align="left">               </td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(if&nbsp;(&lt;&nbsp;c&nbsp;0)</tt>          </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>c</tt>,<tt>b</tt>} </td><td nowrap="nowrap" align="left"></td></tr><tr><td nowrap="nowrap" align="center">
<img src="kents-notes-on-register-alloc_files/0.gif" alt="&lt;graphic&gt;"> </td><td nowrap="nowrap" align="left"> <i>before consequent:</i>     </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>c</tt>} </td><td nowrap="nowrap" align="left"></td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>&nbsp;&nbsp;&nbsp;&nbsp;(nop)</tt>            </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>c</tt>} </td><td nowrap="nowrap" align="left"></td></tr><tr><td nowrap="nowrap" align="center">
<img src="kents-notes-on-register-alloc_files/0.gif" alt="&lt;graphic&gt;"> </td><td nowrap="nowrap" align="left"> <i>before alternative:</i>    </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>c</tt>,<tt>b</tt>} </td><td nowrap="nowrap" align="left"></td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;c&nbsp;(+&nbsp;c&nbsp;b)))</tt></td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>c</tt>} </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>}</td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(set!&nbsp;rax&nbsp;(+&nbsp;c&nbsp;1))</tt>   </td><td nowrap="nowrap" align="left"> {<tt>rax</tt>,<tt>rbp</tt>,<tt>r15</tt>} </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>}</td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(r15&nbsp;rax&nbsp;rbp))</tt>       </td><td nowrap="nowrap" align="left"> {<tt>rax</tt>,<tt>rbp</tt>} </td><td nowrap="nowrap" align="left"></td></tr><tr><td colspan="4" nowrap="nowrap" align="left">

conflicts for
    <tt>a</tt>: {},
    <tt>b</tt>: {},
    <tt>c</tt>: {<tt>r15</tt>,<tt>rbp</tt>}

</td></tr></tbody></table>

<p>
</p><p>9.&nbsp;The predicate adds <tt>c</tt>, but <tt>c</tt> is already there,
so the set does not change.

</p><p></p><table border="1"><tbody><tr><td nowrap="nowrap" align="center">

              </td><td nowrap="nowrap" align="left"> instruction          </td><td nowrap="nowrap" align="left"> live after instruction </td><td nowrap="nowrap" align="left"> live after RHS</td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(set!&nbsp;a&nbsp;r8)</tt>          </td><td nowrap="nowrap" align="left"> </td><td nowrap="nowrap" align="left"> </td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(set!&nbsp;b&nbsp;fv0)</tt>         </td><td nowrap="nowrap" align="left"> </td><td nowrap="nowrap" align="left"> </td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(set!&nbsp;c&nbsp;(+&nbsp;a&nbsp;2))</tt>     </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>c</tt>,<tt>b</tt>} </td><td nowrap="nowrap" align="left"> </td></tr><tr><td nowrap="nowrap" align="center">
<img src="kents-notes-on-register-alloc_files/0.gif" alt="&lt;graphic&gt;"> </td><td nowrap="nowrap" align="left"> <tt>(if&nbsp;(&lt;&nbsp;c&nbsp;0)</tt>          </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>c</tt>,<tt>b</tt>} </td><td nowrap="nowrap" align="left"></td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>&nbsp;&nbsp;&nbsp;&nbsp;(nop)</tt>            </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>c</tt>} </td><td nowrap="nowrap" align="left"></td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;c&nbsp;(+&nbsp;c&nbsp;b)))</tt></td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>c</tt>} </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>}</td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(set!&nbsp;rax&nbsp;(+&nbsp;c&nbsp;1))</tt>   </td><td nowrap="nowrap" align="left"> {<tt>rax</tt>,<tt>rbp</tt>,<tt>r15</tt>} </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>}</td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(r15&nbsp;rax&nbsp;rbp))</tt>       </td><td nowrap="nowrap" align="left"> {<tt>rax</tt>,<tt>rbp</tt>} </td><td nowrap="nowrap" align="left"></td></tr><tr><td colspan="4" nowrap="nowrap" align="left">

conflicts for
    <tt>a</tt>: {},
    <tt>b</tt>: {},
    <tt>c</tt>: {<tt>r15</tt>,<tt>rbp</tt>}

</td></tr></tbody></table>

<p>
</p><p>10.&nbsp;The assignment kills <tt>c</tt>.
<tt>r15</tt>, <tt>rbp</tt>, and <tt>b</tt> are live here, where <tt>c</tt> is assigned.
We already know that <tt>c</tt> conflicts with <tt>r15</tt> and <tt>rbp</tt>, but
we now also know that <tt>c</tt> conflicts with <tt>b</tt> and <tt>b</tt> conflicts
with <tt>c</tt>.

</p><p></p><table border="1"><tbody><tr><td nowrap="nowrap" align="center">

              </td><td nowrap="nowrap" align="left"> instruction          </td><td nowrap="nowrap" align="left"> live after instruction </td><td nowrap="nowrap" align="left"> live after RHS</td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(set!&nbsp;a&nbsp;r8)</tt>          </td><td nowrap="nowrap" align="left"> </td><td nowrap="nowrap" align="left"> </td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(set!&nbsp;b&nbsp;fv0)</tt>         </td><td nowrap="nowrap" align="left"> </td><td nowrap="nowrap" align="left"> </td></tr><tr><td nowrap="nowrap" align="center">
<img src="kents-notes-on-register-alloc_files/0.gif" alt="&lt;graphic&gt;"> </td><td nowrap="nowrap" align="left"> <tt>(set!&nbsp;c&nbsp;(+&nbsp;a&nbsp;2))</tt>     </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>c</tt>,<tt>b</tt>} </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>b</tt>} </td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(if&nbsp;(&lt;&nbsp;c&nbsp;0)</tt>          </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>c</tt>,<tt>b</tt>} </td><td nowrap="nowrap" align="left"></td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>&nbsp;&nbsp;&nbsp;&nbsp;(nop)</tt>            </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>c</tt>} </td><td nowrap="nowrap" align="left"></td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;c&nbsp;(+&nbsp;c&nbsp;b)))</tt></td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>c</tt>} </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>}</td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(set!&nbsp;rax&nbsp;(+&nbsp;c&nbsp;1))</tt>   </td><td nowrap="nowrap" align="left"> {<tt>rax</tt>,<tt>rbp</tt>,<tt>r15</tt>} </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>}</td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(r15&nbsp;rax&nbsp;rbp))</tt>       </td><td nowrap="nowrap" align="left"> {<tt>rax</tt>,<tt>rbp</tt>} </td><td nowrap="nowrap" align="left"></td></tr><tr><td colspan="4" nowrap="nowrap" align="left">

conflicts for
    <tt>a</tt>: {},
    <tt>b</tt>: {<tt>c</tt>},
    <tt>c</tt>: {<tt>b</tt>,<tt>r15</tt>,<tt>rbp</tt>}

</td></tr></tbody></table>

<p>
</p><p>11.&nbsp;The right-hand side adds <tt>a</tt>.

</p><p></p><table border="1"><tbody><tr><td nowrap="nowrap" align="center">

              </td><td nowrap="nowrap" align="left"> instruction          </td><td nowrap="nowrap" align="left"> live after instruction </td><td nowrap="nowrap" align="left"> live after RHS</td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(set!&nbsp;a&nbsp;r8)</tt>          </td><td nowrap="nowrap" align="left"> </td><td nowrap="nowrap" align="left"> </td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(set!&nbsp;b&nbsp;fv0)</tt>         </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>b</tt>,<tt>a</tt>} </td><td nowrap="nowrap" align="left"> </td></tr><tr><td nowrap="nowrap" align="center">
<img src="kents-notes-on-register-alloc_files/0.gif" alt="&lt;graphic&gt;"> </td><td nowrap="nowrap" align="left"> <tt>(set!&nbsp;c&nbsp;(+&nbsp;a&nbsp;2))</tt>     </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>c</tt>,<tt>b</tt>} </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>b</tt>} </td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(if&nbsp;(&lt;&nbsp;c&nbsp;0)</tt>          </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>c</tt>,<tt>b</tt>} </td><td nowrap="nowrap" align="left"></td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>&nbsp;&nbsp;&nbsp;&nbsp;(nop)</tt>            </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>c</tt>} </td><td nowrap="nowrap" align="left"></td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;c&nbsp;(+&nbsp;c&nbsp;b)))</tt></td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>c</tt>} </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>}</td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(set!&nbsp;rax&nbsp;(+&nbsp;c&nbsp;1))</tt>   </td><td nowrap="nowrap" align="left"> {<tt>rax</tt>,<tt>rbp</tt>,<tt>r15</tt>} </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>}</td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(r15&nbsp;rax&nbsp;rbp))</tt>       </td><td nowrap="nowrap" align="left"> {<tt>rax</tt>,<tt>rbp</tt>} </td><td nowrap="nowrap" align="left"></td></tr><tr><td colspan="4" nowrap="nowrap" align="left">

conflicts for
    <tt>a</tt>: {},
    <tt>b</tt>: {<tt>c</tt>},
    <tt>c</tt>: {<tt>b</tt>,<tt>r15</tt>,<tt>rbp</tt>}

</td></tr></tbody></table>

<p>
</p><p>12.&nbsp;The assignment kills <tt>b</tt>.
<tt>r15</tt>, <tt>rbp</tt>, and <tt>a</tt> are live here, where <tt>b</tt> is assigned,
so we record that <tt>b</tt> conflicts with <tt>r15</tt>, <tt>rbp</tt>, and <tt>a</tt> and that
<tt>a</tt> conflicts with <tt>b</tt>.

</p><p></p><table border="1"><tbody><tr><td nowrap="nowrap" align="center">

              </td><td nowrap="nowrap" align="left"> instruction          </td><td nowrap="nowrap" align="left"> live after instruction </td><td nowrap="nowrap" align="left"> live after RHS</td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(set!&nbsp;a&nbsp;r8)</tt>          </td><td nowrap="nowrap" align="left"> </td><td nowrap="nowrap" align="left"> </td></tr><tr><td nowrap="nowrap" align="center">
<img src="kents-notes-on-register-alloc_files/0.gif" alt="&lt;graphic&gt;"> </td><td nowrap="nowrap" align="left"> <tt>(set!&nbsp;b&nbsp;fv0)</tt>         </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>b</tt>,<tt>a</tt>} </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>a</tt>} </td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(set!&nbsp;c&nbsp;(+&nbsp;a&nbsp;2))</tt>     </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>c</tt>,<tt>b</tt>} </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>b</tt>} </td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(if&nbsp;(&lt;&nbsp;c&nbsp;0)</tt>          </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>c</tt>,<tt>b</tt>} </td><td nowrap="nowrap" align="left"></td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>&nbsp;&nbsp;&nbsp;&nbsp;(nop)</tt>            </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>c</tt>} </td><td nowrap="nowrap" align="left"></td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;c&nbsp;(+&nbsp;c&nbsp;b)))</tt></td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>c</tt>} </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>}</td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(set!&nbsp;rax&nbsp;(+&nbsp;c&nbsp;1))</tt>   </td><td nowrap="nowrap" align="left"> {<tt>rax</tt>,<tt>rbp</tt>,<tt>r15</tt>} </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>}</td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(r15&nbsp;rax&nbsp;rbp))</tt>       </td><td nowrap="nowrap" align="left"> {<tt>rax</tt>,<tt>rbp</tt>} </td><td nowrap="nowrap" align="left"></td></tr><tr><td colspan="4" nowrap="nowrap" align="left">

conflicts for
    <tt>a</tt>: {<tt>b</tt>},
    <tt>b</tt>: {<tt>r15</tt>,<tt>rbp</tt>,<tt>a</tt>,<tt>c</tt>},
    <tt>c</tt>: {<tt>b</tt>,<tt>r15</tt>,<tt>rbp</tt>}

</td></tr></tbody></table>

<p>
</p><p>13.&nbsp;The right-hand side adds nothing, since we ignore frame variables.

</p><p></p><table border="1"><tbody><tr><td nowrap="nowrap" align="center">

              </td><td nowrap="nowrap" align="left"> instruction          </td><td nowrap="nowrap" align="left"> live after instruction </td><td nowrap="nowrap" align="left"> live after RHS</td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(set!&nbsp;a&nbsp;r8)</tt>          </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>a</tt>} </td><td nowrap="nowrap" align="left"> </td></tr><tr><td nowrap="nowrap" align="center">
<img src="kents-notes-on-register-alloc_files/0.gif" alt="&lt;graphic&gt;"> </td><td nowrap="nowrap" align="left"> <tt>(set!&nbsp;b&nbsp;fv0)</tt>         </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>b</tt>,<tt>a</tt>} </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>a</tt>} </td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(set!&nbsp;c&nbsp;(+&nbsp;a&nbsp;2))</tt>     </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>c</tt>,<tt>b</tt>} </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>b</tt>} </td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(if&nbsp;(&lt;&nbsp;c&nbsp;0)</tt>          </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>c</tt>,<tt>b</tt>} </td><td nowrap="nowrap" align="left"></td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>&nbsp;&nbsp;&nbsp;&nbsp;(nop)</tt>            </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>c</tt>} </td><td nowrap="nowrap" align="left"></td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;c&nbsp;(+&nbsp;c&nbsp;b)))</tt></td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>c</tt>} </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>}</td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(set!&nbsp;rax&nbsp;(+&nbsp;c&nbsp;1))</tt>   </td><td nowrap="nowrap" align="left"> {<tt>rax</tt>,<tt>rbp</tt>,<tt>r15</tt>} </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>}</td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(r15&nbsp;rax&nbsp;rbp))</tt>       </td><td nowrap="nowrap" align="left"> {<tt>rax</tt>,<tt>rbp</tt>} </td><td nowrap="nowrap" align="left"></td></tr><tr><td colspan="4" nowrap="nowrap" align="left">

conflicts for
    <tt>a</tt>: {<tt>b</tt>},
    <tt>b</tt>: {<tt>r15</tt>,<tt>rbp</tt>,<tt>a</tt>,<tt>c</tt>},
    <tt>c</tt>: {<tt>b</tt>,<tt>r15</tt>,<tt>rbp</tt>}

</td></tr></tbody></table>

<p>
</p><p>14.&nbsp;The assignment kills <tt>a</tt>.
<tt>r15</tt> and <tt>rbp</tt> are live here, where <tt>a</tt> is assigned,
so we record that <tt>a</tt> conflicts with <tt>r15</tt> and <tt>rbp</tt>.

</p><p></p><table border="1"><tbody><tr><td nowrap="nowrap" align="center">

              </td><td nowrap="nowrap" align="left"> instruction          </td><td nowrap="nowrap" align="left"> live after instruction </td><td nowrap="nowrap" align="left"> live after RHS</td></tr><tr><td nowrap="nowrap" align="center">
<img src="kents-notes-on-register-alloc_files/0.gif" alt="&lt;graphic&gt;"> </td><td nowrap="nowrap" align="left"> <tt>(set!&nbsp;a&nbsp;r8)</tt>          </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>a</tt>} </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>} </td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(set!&nbsp;b&nbsp;fv0)</tt>         </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>b</tt>,<tt>a</tt>} </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>a</tt>} </td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(set!&nbsp;c&nbsp;(+&nbsp;a&nbsp;2))</tt>     </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>c</tt>,<tt>b</tt>} </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>b</tt>} </td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(if&nbsp;(&lt;&nbsp;c&nbsp;0)</tt>          </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>c</tt>,<tt>b</tt>} </td><td nowrap="nowrap" align="left"></td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>&nbsp;&nbsp;&nbsp;&nbsp;(nop)</tt>            </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>c</tt>} </td><td nowrap="nowrap" align="left"></td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;c&nbsp;(+&nbsp;c&nbsp;b)))</tt></td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>c</tt>} </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>}</td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(set!&nbsp;rax&nbsp;(+&nbsp;c&nbsp;1))</tt>   </td><td nowrap="nowrap" align="left"> {<tt>rax</tt>,<tt>rbp</tt>,<tt>r15</tt>} </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>}</td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(r15&nbsp;rax&nbsp;rbp))</tt>       </td><td nowrap="nowrap" align="left"> {<tt>rax</tt>,<tt>rbp</tt>} </td><td nowrap="nowrap" align="left"></td></tr><tr><td colspan="4" nowrap="nowrap" align="left">

conflicts for
    <tt>a</tt>: {<tt>r15</tt>,<tt>rbp</tt>,<tt>b</tt>},
    <tt>b</tt>: {<tt>r15</tt>,<tt>rbp</tt>,<tt>a</tt>,<tt>c</tt>},
    <tt>c</tt>: {<tt>b</tt>,<tt>r15</tt>,<tt>rbp</tt>}

</td></tr></tbody></table>

<p>
</p><p>15.&nbsp;The right-hand side adds <tt>r8</tt>, so the live set on entry contains
<tt>rbp</tt>, <tt>r15</tt>, <tt>r8</tt>.
If it contained anything other than registers, this would indicate a bug
in our source program.

</p><p></p><table border="1"><tbody><tr><td nowrap="nowrap" align="center">

              </td><td nowrap="nowrap" align="left"> instruction          </td><td nowrap="nowrap" align="left"> live after instruction </td><td nowrap="nowrap" align="left"> live after RHS</td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <i>on entry</i>      </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>r8</tt>} </td><td nowrap="nowrap" align="left"></td></tr><tr><td nowrap="nowrap" align="center">
<img src="kents-notes-on-register-alloc_files/0.gif" alt="&lt;graphic&gt;"> </td><td nowrap="nowrap" align="left"> <tt>(set!&nbsp;a&nbsp;r8)</tt>          </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>a</tt>} </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>} </td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(set!&nbsp;b&nbsp;fv0)</tt>         </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>b</tt>,<tt>a</tt>} </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>a</tt>} </td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(set!&nbsp;c&nbsp;(+&nbsp;a&nbsp;2))</tt>     </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>c</tt>,<tt>b</tt>} </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>b</tt>} </td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(if&nbsp;(&lt;&nbsp;c&nbsp;0)</tt>          </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>c</tt>,<tt>b</tt>} </td><td nowrap="nowrap" align="left"></td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>&nbsp;&nbsp;&nbsp;&nbsp;(nop)</tt>            </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>c</tt>} </td><td nowrap="nowrap" align="left"></td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;c&nbsp;(+&nbsp;c&nbsp;b)))</tt></td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>c</tt>} </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>}</td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(set!&nbsp;rax&nbsp;(+&nbsp;c&nbsp;1))</tt>   </td><td nowrap="nowrap" align="left"> {<tt>rax</tt>,<tt>rbp</tt>,<tt>r15</tt>} </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>}</td></tr><tr><td nowrap="nowrap" align="center">
              </td><td nowrap="nowrap" align="left"> <tt>(r15&nbsp;rax&nbsp;rbp))</tt>       </td><td nowrap="nowrap" align="left"> {<tt>rax</tt>,<tt>rbp</tt>} </td><td nowrap="nowrap" align="left"></td></tr><tr><td colspan="4" nowrap="nowrap" align="left">

conflicts for
    <tt>a</tt>: {<tt>r15</tt>,<tt>rbp</tt>,<tt>b</tt>},
    <tt>b</tt>: {<tt>r15</tt>,<tt>rbp</tt>,<tt>a</tt>,<tt>c</tt>},
    <tt>c</tt>: {<tt>b</tt>,<tt>r15</tt>,<tt>rbp</tt>}

</td></tr></tbody></table>

<p>
</p><p>The live analysis is now complete, and we have our final conflict sets:

</p><p>
</p><table><tbody><tr><td nowrap="nowrap" align="left">
<tt>a</tt>: </td><td nowrap="nowrap" align="left"> {<tt>r15</tt>,<tt>rbp</tt>,<tt>b</tt>}</td></tr><tr><td nowrap="nowrap" align="left">
<tt>b</tt>: </td><td nowrap="nowrap" align="left"> {<tt>rbp</tt>,<tt>r15</tt>,<tt>a</tt>,<tt>c</tt>}</td></tr><tr><td nowrap="nowrap" align="left">
<tt>c</tt>: </td><td nowrap="nowrap" align="left"> {<tt>b</tt>,<tt>r15</tt>,<tt>rbp</tt>}
</td></tr></tbody></table>

<p>
</p><p>There are some important things to note:

</p><p>
</p><ul>
<li>A variable never appears in its own conflict set.
      In order for it to appear, it would have to be assigned where it is live,
      but as soon as it is assigned, it becomes dead.
      By using the live set in the interval between the computation of the
      right-hand side of the assignment and the assignment itself, we avoid
      having to do anything special to remove self conflicts.
      For example, when handling the assignment <tt>(set!&nbsp;c&nbsp;(+&nbsp;c&nbsp;b))</tt>, we
      first remove <tt>c</tt> from the running live set, then record the
      conflicts between <tt>c</tt> and any registers and variables left in the
      live set, then add <tt>c</tt> back, along with <tt>b</tt>.

<p>
</p></li><li>We don't maintain conflict sets for registers.
      Registers are fixed; we can't, for instance, decide to locate
      <tt>r8</tt> in <tt>rax</tt>.
      So the register allocator will never need to ask with which other
      registers and variables a register conflicts.

<p>
</p></li><li>In the example above, it happens that <tt>r8</tt> is not live at the
      point where <tt>a</tt> is assigned to <tt>r8</tt>.
      Even if <tt>r8</tt> were live, we would not add <tt>r8</tt> to
      <tt>a</tt>'s conflict set, since the assignment is a straight move
      of one to the other.

<p>
</p></li><li>The set of conflicts we record at an assignment depends only on
      the left-hand-side variable and the set of variables that are
      live just before the assignment occurs.
      The set of variables referenced on the right-hand side are
      <i>irrelevant</i> when determining conflicts.
      So when we saw <tt>(set!&nbsp;c&nbsp;(+&nbsp;c&nbsp;b))</tt> we <i>did not</i> add a
      conflict between <tt>b</tt> and <tt>c</tt>, though we would have
      if <tt>b</tt> had been live at that point.

<p>
</p></li><li>It is possible for a variable to be assigned at some point
      where it is not live.
      If this occurs, we could discard the assignment and ignore
      any variable and register references on the right-hand side
      of the assignment.
      If we do this, we'll usually end up with fewer conflicts.
      We don't bother however, and instead assume that some earlier,
      possibly optional, optimization pass has discarded useless
      assignments.
      In general, we don't want to complicate our required passes by
      performing optimizations, and we want to give users of our
      compiler the choice of whether optimizations should be
      enabled.
</li></ul>
<p>

</p><p>
While simply unioning the consequent and alternative live sets before
processing the predicate of an <tt>if</tt> expression will work, we can
gather more precise live information in the presence of the boolean
constants <tt>(true)</tt> and <tt>(false)</tt> by maintaining separate
true and false live sets in predicate context.
For all <tt>if</tt> expressions, we pass our predicate handler
two live sets, a true live set (from the consequent expression) and a
false live set (from the alternative expression).
The handler propagates the two sets through to the consequent and
alternative of any nested <tt>if</tt> expression and the last
subexpression of any nested <tt>begin</tt> expression.
If it finds <tt>(true)</tt> or <tt>(false)</tt>, it returns the true
live set or the false live set accordingly.
In the only other case, that of a predicate primitive call, it must
union the two sets before processing the call, since the boolean value
of the primitive call is unknown.

</p><p>
This pays off when variable references occur in dead code because the
entire test expression is a constant, i.e., in the following cases.

</p><p>

</p><p><tt>(if&nbsp;(true)&nbsp;<i>e<sub>1</sub></i>&nbsp;<i>e<sub>2</sub></i>)<br>

(if&nbsp;(false)&nbsp;<i>e<sub>1</sub></i>&nbsp;<i>e<sub>2</sub></i>)</tt>
</p><p>In the first case, only those variables live on entry to <tt><i>e<sub>1</sub></i></tt> will
be shown live on entry to the <tt>if</tt> expression, while in the second
case, only those variables live on entry to <tt><i>e<sub>2</sub></i></tt> will be shown live
on entry to the <tt>if</tt> expression,

</p><p>
If this were the only benefit, we would not bother, since we 
assume that such expressions would have been simplified by some earlier
optimization pass, if desired.
It also, however, pays off in more subtle cases like the one below.

</p><p>

</p><p><tt>(if&nbsp;(if&nbsp;<i>e<sub>1</sub></i><br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin&nbsp;<i>e<sub>2</sub></i>&nbsp;(false))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>e<sub>3</sub></i>)<br>

&nbsp;&nbsp;&nbsp;&nbsp;<i>e<sub>4</sub></i><br>

&nbsp;&nbsp;&nbsp;&nbsp;<i>e<sub>5</sub></i>)</tt>
</p><p>Since <tt><i>e<sub>4</sub></i></tt> cannot be reached from code that passes through <tt><i>e<sub>2</sub></i></tt>,
the set of variables that are live after <tt><i>e<sub>2</sub></i></tt> includes only those
that are live going into <tt><i>e<sub>5</sub></i></tt>.
By returning only the false live set for the occurrence of
<tt>(false)</tt> just after <tt><i>e<sub>2</sub></i></tt> we ensure that these are the only
variables to make it through.

</p><p>

<a name="g2"></a>

</p><h4><br><a name="./assign4:h2"></a>1.2. Register Assignment<a name="section:regassign"></a></h4>



<p>
The register assignment algorithm takes two inputs:  a list of variables
and a conflict table.
It returns a list of register assignments for all or some of the variables.
It is most easily described recursively as follows.

</p><p>
</p><ul>
<li>If the list of variables is empty, return an empty list of register
    assignments.

<p>
</p></li><li>Pick a low-degree variable from the
    list of variables, if one exists.  Otherwise pick any
    variable.  A low-degree variable is one that conflicts with with
    fewer than <i>k</i> variables or registers in the current conflict table.

<p>
</p></li><li>Recur with the picked variable removed from the list of variables
    and the picked variable removed from the conflict lists of the other
    variables in the conflict table.
    (Thus, we expect the recursive call to assign registers to a list one
    shorter with a conflict graph that possibly has fewer conflicts.)
    The recursive call should return
    a list of register assignments for (at least some of) the remaining
    variables.

<p>
</p></li><li>Attempt to select a register for the picked variable, avoiding any
    registers the picked variable conflicts with and any registers
    to which a conflicting variable is assigned in the list of register
    assignments returned by the recursive call.  This step will succeed
    if a low-degree variable is picked, and may or may not succeed
    otherwise.  If it succeeds, add the assignment to the list of
    register assignments and return the updated list.  Otherwise return
    the non-updated list.
</li></ul>
<p>

</p><p>
This algorithm is an adaptation of the optimistic register allocation
described in "Improvements to graph coloring register allocation"
(ACM TOPLAS 6:3, 1994) by Preston Briggs, et al.

</p><p>
If the list of register assignments returned by the register allocator
contains an assignment for each variable in the original set of variables,
the register allocator has succeeded.
Otherwise, the register allocator has failed, and the set of variables
for which the list <i>does not</i> contain assignments must be
<i>spilled</i>, i.e., assigned frame locations.
We are not handling frame allocation at present, so the register
allocator should simply error out with an appropriate message if
this happens.

</p>



<h4><br><a name="./assign4:h4"></a>1.4. Conflict Graph Representation<a name="section:cgrepn"></a></h4>



<p>
A conflict graph is most easily represented in Scheme as an association
list mapping each variable to a list of the variables and registers
with which it conflicts.
For example,

</p><p>

</p><p><tt>((a&nbsp;r15&nbsp;rbp&nbsp;b)<br>

&nbsp;(b&nbsp;r15&nbsp;rbp&nbsp;a&nbsp;c)<br>

&nbsp;(c&nbsp;b&nbsp;r15&nbsp;rbp))</tt>
</p><p>represents the conflict sets derived for the example in the preceding
section.
The represention is redundant in that conflicts between two variables
are listed twice, once for each variable, but the efficiency with
which the conflicts of a particular variable can be determined more
than makes up for the cost of maintaining the redundant information.

</p><p>
The <a href="file:///Users/wilbowma/workspace/compiler-class/cgi/home/tools/helpers.ss"> </a>set operations can be used along with
<tt>assq</tt> and <tt>set-cdr!</tt> to manipulate conflict graphs
represented in this manner.

</p><p>
Again, we would probably choose a more efficient (and complicated)
representation in a production compiler, but this representation will do
for our purposes.


</p><p>


</p><p>

<a name="g5"></a>

</p>

















































&nbsp;2010&nbsp;R. Kent Dybvig, Andy Keep
